{
  "associatedLayout": "Game",
  "name": "Global EventsJS",
  "events": [
    {
      "colorB": 228,
      "colorG": 176,
      "colorR": 74,
      "creationTime": 0,
      "name": "Game Initialization",
      "source": "",
      "type": "BuiltinCommonInstructions::Group",
      "events": [
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Properties",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (!runtimeScene.getGame().getVariables().get(\"DataInitialized\").getAsBoolean()) { // All persistent data is attached to gdjs so that it isn't reset on scene change",
                "    gdjs.FDGameData = {};",
                "    const FDSG = gdjs.FDGameData; // This way data can be accessed through a simpler variable name (FDSG = Frederick-Douglass Square Game)",
                "",
                "    /// PUT ALL PERSISTENT DATA (FUNCTION DEFINITIONS AND VARIABLES AND STUFF) HERE! MAKE SURE TO PREFIX WITH 'FDSG.'!",
                "",
                "    /**",
                "     * @type {{",
                "     * startLayout: string",
                "     * currentLayout: string",
                "     * runtimeScene: gdjs.RuntimeScene",
                "     * collectibles: { [key:string]: boolean}",
                "     * isInspecting: boolean",
                "     * }}",
                "     */",
                "    FDSG.GameVars = { // This holds variables that are important for tracking/managing the current game variables",
                "        startLayout: \"FDS North\", // The starting layout",
                "        currentLayout: \"\", // This is used to load the corrent layout on transitions",
                "        _currentInspect: \"\", // Used to track which Inspect is currently loaded",
                "        runtimeScene: runtimeScene,",
                "            // Used for accessing the current RuntimeScene object, since otherwise the definitions here will try and access the old object",
                "        collectibles: {}, /* This is used to track which collectibles have been collected. Each collectible has a uniqueID,",
                "                          and is either true (collected) or false (not collected) */",
                "        statuesCollected: 0, // The number of statues Collected",
                "        // Flags",
                "        _isInspecting: false,",
                "        // Getters and Setters",
                "        // currentInspect",
                "            get currentInspect() {",
                "                return this._currentInspect;",
                "            },",
                "            set currentInspect(inspectName) {",
                "                if (inspectName != \"\" && !(inspectName in FDSG._LayoutInspects[GameVars.currentLayout])) {",
                "                    console.log(`Error: ${inspectName} is not a registered inspect`);",
                "                } else {",
                "                    FDSG.loadInspect(inspectName);",
                "                    this._currentInspect = inspectName;",
                "                }",
                "            },",
                "        // isInspecting",
                "            get isInspecting() {",
                "                return this._isInspecting;",
                "            },",
                "            set isInspecting(value) {",
                "                FDSG.darkEffect(value, true); // Activate/Deactivate the dark screen effect",
                "                const inspectLayer = GameVars.runtimeScene.getLayer(\"InspectObjects\"); // Get the InspectObjects layer",
                "                const inspectUILayer = GameVars.runtimeScene.getLayer(\"InspectUI\");",
                "                inspectLayer.show(value); // Show/Hide the layer",
                "                inspectUILayer.show(value);",
                "                FDSG.ClickableLayers[\"InspectObjects\"] = value; // Enable/Disable the relevant layers clicks",
                "                FDSG.ClickableLayers[\"InspectUI\"] = value;",
                "                FDSG.ClickableLayers[\"UI\"] = !value;",
                "                FDSG.ClickableLayers[\"SceneObjects\"] = !value;",
                "                if (!value) {",
                "                    GameVars.currentInspect = \"\";",
                "                } ",
                "            }",
                "    }",
                "    const GameVars = FDSG.GameVars; // Simpler reference variable",
                "    GameVars.currentLayout = GameVars.startLayout // Load the starting layout as default",
                "    const Game = GameVars.runtimeScene.getGame();",
                "",
                "    FDSG._ClickableObjects = {}; // Stores registered actions to run when objects are clicked",
                "",
                "    FDSG.ClickableLayers = { // Similar but for disabling layers instead of individual objects",
                "        \"UI\": true,",
                "        \"SceneObjects\": true,",
                "        \"InspectObjects\": false,",
                "        \"InspectUI\": false",
                "    }",
                "",
                "    FDSG._LayoutInspects = {}; // Used for tracking Inspect objects and their positions",
                "",
                "    // OBJECT GROUPS ###################################################################################################################################",
                "    // Since object groups aren't really easy to access in JS (or in general imo), we can define object groups by object name here",
                "    FDSG.ObjectGroups = {",
                "        \"Collectibles\": [",
                "            \"StatueCollectible\"",
                "        ]",
                "    }",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": []
        },
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Functions",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const FDSG = gdjs.FDGameData;",
                "const GameVars = FDSG.GameVars;",
                "const Game = GameVars.runtimeScene.getGame();",
                "",
                "if (!runtimeScene.getGame().getVariables().get(\"DataInitialized\").getAsBoolean()) {",
                "    ",
                "    // FUNCTIONS #######################################################################################################################################",
                "",
                "    /**",
                "     * Returns all object names in the current game",
                "     * @returns {string[]}",
                "    */",
                "    FDSG.getAllObjects = function() {",
                "        // Gets all object types in the game",
                "        const gameData = Game.getGameData().objects;",
                "        const gameObjects = []; // This stores all object types",
                "        for (const object of gameData) {",
                "            gameObjects.push(object.name);",
                "        }",
                "        return gameObjects;",
                "    }",
                "",
                "    /**",
                "     * Returns all instances of any object in the current scene",
                "     * @param {gdjs.RuntimeScene} runtimeScene the target runtimeScene",
                "     * @param {string} layer? Only retrieve objects from this layer. Defaults to all layers",
                "     * @param {\"object\"|\"array\"} returnType? Whether to return all instances in an object grouped by their objectName (default) or an array",
                "     * @returns {Object} All objects in the current scene and their instances",
                "     */",
                "    FDSG.getAllSceneInstances = function(runtimeScene, layer = \"all\", returnType = \"object\") {",
                "        // Returns all the instances in the current scene (Not sure why the API doesn't already have this)",
                "        const objectTypes = FDSG.getAllObjects();",
                "        const sceneInstancesArray = [];",
                "        const sceneInstancesObject = {};",
                "        for (const object of objectTypes) {",
                "            const instances = runtimeScene.getObjects(object);",
                "            for (const instance of instances) {",
                "                if (layer == instance.layer || layer == \"all\") {",
                "                    if (returnType == \"array\") {",
                "                        sceneInstancesArray.push(instance);",
                "                    } else {",
                "                        if (!(object in sceneInstancesObject)) {",
                "                            sceneInstancesObject[object] = [];",
                "                        }",
                "                        sceneInstancesObject[object].push(instance);",
                "                    }",
                "                }",
                "            }",
                "        }",
                "        if (returnType == \"array\") {",
                "            return sceneInstancesArray;",
                "        } else {",
                "            return sceneInstancesObject;",
                "        }",
                "    }",
                "    ",
                "    /**",
                "     * Loads proper layouts for the scene and handles layout elements",
                "     */",
                "    FDSG.initScene = function() {",
                "        // Loads proper layouts and initializes necessary values",
                "        //console.log(`initializing ${FDSG.GameVars.currentLayout}`);",
                "        gdjs.evtTools.runtimeScene.createObjectsFromExternalLayout(GameVars.runtimeScene, \"UI\", 0, 0, false); // Load the UI",
                "        gdjs.evtTools.runtimeScene.createObjectsFromExternalLayout(GameVars.runtimeScene, GameVars.currentLayout, 0, 0, false);",
                "                // Load the layout for the current screen",
                "            ",
                "        // Disable the darkening effects",
                "        const backgroundLayer = GameVars.runtimeScene.getLayer(\"Background\");",
                "        const objectsLayer = GameVars.runtimeScene.getLayer(\"SceneObjects\");",
                "        const uiLayer = GameVars.runtimeScene.getLayer(\"UI\");",
                "        const inspectUILayer = GameVars.runtimeScene.getLayer(\"InspectUI\");",
                "        for (const layer of [backgroundLayer, objectsLayer, uiLayer]) {",
                "            layer.enableEffect(\"Darken\", false);",
                "        }",
                "",
                "        // COLLECTIBLES HANDLING",
                "        for (const collectibleType of FDSG.ObjectGroups.Collectibles) { // Check all instances of collectible objects to see if they've been collected already",
                "            const collectibleObjects = GameVars.runtimeScene.getObjects(collectibleType);",
                "            for (const collectible of collectibleObjects) {",
                "                const uniqueID = `${collectible.name}-${GameVars.currentLayout}-${collectible.getX()}-${collectible.getY()}`;",
                "                    /* Each collectible instance is assigned to a unique ID that consists of the type of object, the name of the layout they're in,",
                "                    and their x and y coordinates. This way we can track which objects have been collected or not */",
                "                if (uniqueID in GameVars.collectibles) { // Check if this instance has been registered before",
                "                    if (GameVars.collectibles[uniqueID] == true) { // Check if this item has been collected already",
                "                        collectible.deleteFromScene(GameVars.runtimeScene); // Remove the object from the scene",
                "                    }",
                "                } else { // Collectible has not been registered before",
                "                    GameVars.collectibles[uniqueID] = false; // register the object as not collected yet",
                "                }",
                "            }",
                "        }",
                "        FDSG.updateStatueCounter(); // Update the StatuesCollectedCounter to the proper value",
                "",
                "        // INSPECTS HANDLING",
                "        /* All we really do here is check the different \"inspectName\" values in the layout, and then get a map tying each object to its associated inspect.",
                "        Then we just get their initial x and y positions in the layout so we can move them into the camera when they activate",
                "        and move them back when they exit */",
                "        FDSG._LayoutInspects[GameVars.currentLayout] = {}; // Initialize the Layout",
                "        const layoutInspects = FDSG._LayoutInspects[GameVars.currentLayout]; // Simpler reference variable",
                "        const cameraWidth = gdjs.evtTools.camera.getCameraWidth(GameVars.runtimeScene, \"\", 0);",
                "        const cameraHeight = gdjs.evtTools.camera.getCameraHeight(GameVars.runtimeScene, \"\", 0);",
                "        const allInstances = FDSG.getAllSceneInstances(GameVars.runtimeScene, \"InspectObjects\", \"array\");",
                "        for (const inspectObject of FDSG.getAllSceneInstances(GameVars.runtimeScene, \"InspectObjects\", \"array\")) {",
                "            // Get all the objects on the InspectObjects layer and register their positions",
                "            if (!inspectObject.getVariables().has(\"inspectName\")) {",
                "                continue;",
                "            } ",
                "            const inspect = inspectObject.getVariables().get(\"inspectName\").getAsString();",
                "            if (!(inspect in layoutInspects)) {",
                "                layoutInspects[inspect] = { // Register this inspect",
                "                    baseX: inspectObject.getX(), // The initial X and y positions so that we can determine the relative positioning of objects in this inspect",
                "                    baseY: inspectObject.getY(),",
                "                    inspectWidth: 0, // The width of the full inspect (we use this to make sure the inspect is brought to the center of the screen)",
                "                    inspectHeight: 0, // The height of the fll inspect",
                "                    highestX: null, // These will help determine the width and height",
                "                    highestY: null,",
                "                    activeX: null, // Where to move the inspect objects when the inspect activates",
                "                    activeY: null, ",
                "                    instances: [] // The instances in this inspect",
                "                }",
                "            }",
                "            const layoutInspect = layoutInspects[inspect];",
                "            const inspectInstance = {",
                "                object: inspectObject, // The RuntimeObject itself",
                "                initialX: inspectObject.getX(), // The initial x position",
                "                initialY: inspectObject.getY() // The initial y position",
                "            }",
                "            if (inspectInstance.x < layoutInspect.baseX) {layoutInspect.baseX = inspectInstance.x;}",
                "                // We want the leftmost x position so we can determine the relative positioning of all objects in this inspect",
                "            if (inspectInstance.y < layoutInspect.baseY) {layoutInspect.baseY = inspectInstance.y;}",
                "                // We want the topmost y position so we can determine the relative positioning of all objects in this inspect",
                "            if (inspectInstance.initialX + inspectObject.getWidth() > layoutInspect.highestX || layoutInspect.highestX == null) {",
                "                layoutInspect.highestX = inspectInstance.initialX + inspectObject.getWidth();}",
                "            if (inspectInstance.initialY + inspectObject.getHeight() > layoutInspect.highestY || layoutInspect.highestY == null) {",
                "                layoutInspect.highestY = inspectInstance.initialY + inspectObject.getHeight();}",
                "            layoutInspect.instances.push(inspectInstance);",
                "                // Store this object so we can move it when we load this inspect",
                "        }",
                "        for (const inspect in layoutInspects) {",
                "            /* Now that we have all the objects registered, we can calculate the width, height, and active position for the inspect",
                "            This probably wont be necessary since I imagine all of our inspects will be the same width and height,",
                "            but I figured I'd include this for flexibility */",
                "            layoutInspects[inspect].inspectWidth = layoutInspects[inspect].highestX - layoutInspects[inspect].baseX;",
                "            layoutInspects[inspect].inspectHeight = layoutInspects[inspect].highestY - layoutInspects[inspect].baseY;",
                "            layoutInspects[inspect].activeX = (cameraWidth - layoutInspects[inspect].inspectWidth)/2;",
                "            layoutInspects[inspect].activeY = (cameraHeight - layoutInspects[inspect].inspectHeight)/2;",
                "        }",
                "        GameVars._currentInspect = \"\";",
                "    }",
                "",
                "    /**",
                "     * Removes a collectible object from the scene and marks it as collected.",
                "     * @param {gdjs.RuntimeObject} collectible the collectibleObject that's being collected",
                "     * @returns {boolean} If the object was successfully collected",
                "     */",
                "    FDSG.collectObject = function(collectible) {",
                "        if (!FDSG.ObjectGroups.Collectibles.includes(String(collectible.getName()))) {",
                "            console.log(\"Object is not a collectible\");",
                "            return false;",
                "        }",
                "        const uniqueID = `${collectible.name}-${GameVars.currentLayout}-${collectible.getX()}-${collectible.getY()}`;",
                "            // The objects uniqueID to distinguish it from others",
                "        GameVars.collectibles[uniqueID] = true; // Mark as collected",
                "        collectible.deleteFromScene(GameVars.runtimeScene);",
                "        console.log(`Collected ${uniqueID}`);",
                "        return true;",
                "    }",
                "",
                "    /**",
                "     * Darkens the appropriate layers for pausing and inspection",
                "     * @param {boolean} enable Whether to enable or disable the effect",
                "     * @param {boolean} darkenUI Whether to darken the UI layer (for inspects) ",
                "     */",
                "    FDSG.darkEffect = function(enable, darkenUI = false) {",
                "        const backgroundLayer = GameVars.runtimeScene.getLayer(\"Background\");",
                "        const objectsLayer = GameVars.runtimeScene.getLayer(\"SceneObjects\");",
                "        const uiLayer = GameVars.runtimeScene.getLayer(\"UI\");",
                "        const layers = [backgroundLayer, objectsLayer];",
                "        if (darkenUI) {",
                "            layers.push(uiLayer);",
                "        }",
                "        for (const layer of layers) {",
                "            layer.enableEffect(\"Darken\", enable);",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Registers a function to run when an object is clicked.",
                "     * @param {Object} clickConfig The object that holds the listed parameters",
                "     * @param {string|string[]} clickConfig.object The object type or array of object types to register",
                "     * @param {string|string[]} clickConfig.button The mouse button or array of mouse buttons (Left, Right, Middle)",
                "     * @param {\"pressed\"|\"released\"|string[]} clickConfig.duration When the callback should fire",
                "     * @param {(obj: gdjs.RuntimeObject) => void} clickConfig.clickFunction The function that runs when clicked",
                "     * @param {string} [clickConfig.cursor] Optional cursor to show on hover",
                "     */",
                "    FDSG.registerClickableObject = function(clickConfig) {",
                "        var objects = clickConfig.object;",
                "        var clickButtons = clickConfig.button;",
                "        var clickDurations = clickConfig.duration;",
                "        var cursor = (typeof clickConfig.cursor === 'undefined') ? \"pointer\" : clickConfig.cursor; // Cursor defaults to \"pointer\"",
                "        // We put the following parameters in arrays if they're not already.",
                "        /* This is probably overkill since it's unlikely more than one object will be tied to a function, but this only runs once at startup",
                "        so it's not gonna affect performance or anything */",
                "        if (!Array.isArray(objects)) {",
                "            objects = [clickConfig.object];",
                "        }",
                "        if (!Array.isArray(clickButtons)) {",
                "            clickButtons = [clickConfig.button];",
                "        }",
                "        if (!Array.isArray(clickDurations)) {",
                "            clickDurations = [clickConfig.duration];",
                "        }",
                "        for (const object of objects) {",
                "            if (!(object in FDSG._ClickableObjects)) {",
                "                FDSG._ClickableObjects[object] = { // Register the object as clickable and store the necessary properties",
                "                    clickActions: {}, // Stores functions and their triggers",
                "                    cursor: cursor, // What the cursor should turn into when hovering over",
                "                    enabled: true // Useful for disabling interactivity on this object",
                "                }",
                "            }",
                "            let clickObject = FDSG._ClickableObjects[object]; // Easier reference variable",
                "            for (const clickButton of clickButtons) {",
                "                if (!(clickButton in clickObject.clickActions)) { // Register the button",
                "                    clickObject.clickActions[clickButton] = {};",
                "                }",
                "                for (const clickDuration of clickDurations) {",
                "                    if (!(clickDuration in clickObject.clickActions[clickButton])) { // Register the duration",
                "                        clickObject.clickActions[clickButton][clickDuration] = {};",
                "                    }",
                "                    clickObject.clickActions[clickButton][clickDuration] = clickConfig.clickFunction; // Register the clickFunction",
                "                }",
                "            }",
                "        }",
                "    }",
                "   ",
                "    /**",
                "     * Checks clicked objects and runs the appropriate functions",
                "     */",
                "    FDSG.handleClickableObjects = function() {",
                "        let isHovering = false; // Whether the mouse is hovering over a clickable object",
                "        let highestZOrder = -1; // We change the mouse cursor to the one determined by the object closest to the camera",
                "        let cursor = \"default\"; // Default cursor type",
                "        for (const object in FDSG._ClickableObjects) { // Check each object",
                "            const clickObject = FDSG._ClickableObjects[object]; // Easer reference variable",
                "            if (clickObject.enabled) { // Check if the object is disabled",
                "                const objects = GameVars.runtimeScene.getObjects(object);",
                "                for (const instance of objects) { // Check each instance of the object",
                "                    const instanceLayer = instance.getLayer();",
                "                    if (instance.cursorOnObject() && (instanceLayer in FDSG.ClickableLayers) && (FDSG.ClickableLayers[instanceLayer])) {",
                "                        // Check if the cursor is on the object and if its layer is not disabled",
                "                        if (instance.getZOrder() > highestZOrder) { // Only set cursor for the object with the highest Z order",
                "                            cursor = clickObject.cursor;",
                "                        }",
                "                        for (const clickButton in clickObject.clickActions) { // Check each button",
                "                            let clickPressed = gdjs.evtTools.input.isMouseButtonPressed(GameVars.runtimeScene, clickButton);",
                "                            let clickReleased = gdjs.evtTools.input.isMouseButtonReleased(GameVars.runtimeScene, clickButton);",
                "                            for (const clickDuration in clickObject.clickActions[clickButton]) {",
                "                                if ((clickDuration == \"pressed\" && clickPressed) || (clickDuration == \"released\" && clickReleased)) {",
                "                                    clickObject.clickActions[clickButton][clickDuration](instance);",
                "                                        // Run the registered function, passing this instance as an arg",
                "                                }",
                "                            }",
                "                        }",
                "                    }   ",
                "                }",
                "            }",
                "        }",
                "        Game.getRenderer().getCanvas().style.cursor = cursor; // Change the cursor",
                "    }",
                "",
                "    /**",
                "     * Enables/Disables the click callback function of a given object. Useful for pausing functionality under specific circumstances",
                "     * @param {string} object The type of object",
                "     * @param {boolean} enable Set to true to enable the object, set to false to disable the object",
                "     */",
                "    FDSG.enableObjectClick = function(object, enable) {",
                "        if (!(object in FDSG._ClickableObjects)) {",
                "            console.log(`Warning: ${object} not registered as clickable!`);",
                "            return",
                "        }",
                "        FDSG._ClickableObjects[object].enable = enable;",
                "    }",
                "",
                "    /**",
                "     * Enables/Disables the click callback function of all objects on a given layer. Useful for pausing functionality under specific circumstances",
                "     * @param {string} layer The target layer",
                "     * @param {boolean} enable Set to true to enable the layer, set to false to disable the layer",
                "     */",
                "    FDSG.enableLayerClick = function(layer, enable) {",
                "        if (!(layer in FDSG.ClickableLayers)) {",
                "            console.log(`Warning: ${layer} not registered as clickable!`);",
                "            return",
                "        }",
                "        FDSG.ClickableLayers[layer] = enable;",
                "    }",
                "",
                "    /**",
                "     * Brings all objects tied to the given inspect into the scene",
                "     * @param {string} inspect The specific inspect to take objects from",
                "     * @param {boolean} activate Set to true to activate the inspect, set to false to deactivate",
                "     */",
                "    FDSG.loadInspect = function(inspectName) {",
                "        if (GameVars.currentInspect != \"\" && GameVars.currentInspect in FDSG._LayoutInspects[GameVars.currentLayout]) {",
                "                // Check if an inspect is currently loaded",
                "            console.log(\"unloading previous inspect\");",
                "            const previousInspect = FDSG._LayoutInspects[GameVars.currentLayout][GameVars.currentInspect];",
                "            console.log(previousInspect);",
                "            for (const inspectInstance of previousInspect.instances) { // Restore initial position of objects",
                "                let object = inspectInstance.object;",
                "                object.setX(inspectInstance.initialX);",
                "                object.setY(inspectInstance.initialY);",
                "            }",
                "        }",
                "        if (inspectName == \"\") { // This is so we can unload the inspect using the same function",
                "            return",
                "        }",
                "        const layoutInspect = FDSG._LayoutInspects[GameVars.currentLayout][inspectName];",
                "        for (const inspectInstance of layoutInspect.instances) {",
                "            let object = inspectInstance.object;",
                "            if (object.name == \"InspectText\") {",
                "                const innerText = object.getVariables().get(\"innerText\").getAsString();",
                "                console.log(innerText);",
                "                object.setText(innerText);",
                "            }",
                "            let relX = (inspectInstance.initialX - layoutInspect.baseX) + layoutInspect.activeX;",
                "            let relY = (inspectInstance.initialY - layoutInspect.baseY) + layoutInspect.activeY;",
                "            object.setX(relX); // Move the object to the center of the camera, offset by it's relative position in the inspect",
                "            object.setY(relY);",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Sets the value of the StatuesCollectedCounter",
                "     */",
                "    FDSG.updateStatueCounter = function() {",
                "        const statueCounter = GameVars.runtimeScene.getObjects(\"StatuesCollectedCounter\")[0];",
                "        statueCounter.getVariables().get(\"value\").setNumber(GameVars.statuesCollected);",
                "        statueCounter.setText(`Statues Collected: ${GameVars.statuesCollected}`);",
                "    }",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": []
        },
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Clickable Object Registrations",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (!runtimeScene.getGame().getVariables().get(\"DataInitialized\").getAsBoolean()) {",
                "    const FDSG = gdjs.FDGameData;",
                "    const GameVars = FDSG.GameVars;",
                "    const Game = GameVars.runtimeScene.getGame();",
                "    ",
                "    // CLICKABLE OBJECT REGISTRATIONS ##########################################################################################################################",
                "    /*",
                "    This is where you can easily assign objects to specific functions when clicked.",
                "    Just call the FDSG.registerClickableObject() function, passing a clickConfig object with the following properties:",
                "        clickConfig = {",
                "            object|object[]: The type of scene object you're registering",
                "            button|button[]: The mouse button that triggers this function",
                "            duration|duration[]: Whether the function should run as long as the mouse button is held down or just when released",
                "            clickFunction: The function that should run when this object is clicked, with a parameter 'obj' for the instance being clicked.",
                "                It's best to pass an anonymous function of this form: (obj) => {<insert code here>}",
                "            cursor?: If you want the mouse cursor to change when hovering over this object, put it here as a string (defaults to \"pointer\")",
                "        }",
                "    */",
                "",
                "    FDSG.registerClickableObject({",
                "        object: \"TransitionObject\",",
                "        button:\"Left\",",
                "        duration: \"released\",",
                "        clickFunction: (obj) => {",
                "            GameVars.currentLayout = obj.getVariables().get(\"targetLayout\").getAsString();",
                "            gdjs.evtTools.runtimeScene.replaceScene(GameVars.runtimeScene, gdjs.evtTools.runtimeScene.getSceneName(GameVars.runtimeScene));",
                "                // Changes the currentLayout to the layout associated with the TransitionObject and reloads the scene",
                "        }",
                "    });",
                "",
                "    FDSG.registerClickableObject({",
                "        object: \"InspectObject\",",
                "        button: \"Left\",",
                "        duration: \"released\",",
                "        clickFunction: (obj) => {",
                "            const targetInspect = obj.getVariables().get(\"targetInspect\").getAsString();",
                "            if (!(targetInspect in FDSG._LayoutInspects[GameVars.currentLayout])) {",
                "                console.log(`Error: ${inspectName} is not a registered inspect`);",
                "                return",
                "            }",
                "            GameVars.currentInspect = targetInspect;",
                "            GameVars.isInspecting = true;",
                "        },",
                "        cursor: \"help\"",
                "    });",
                "",
                "    FDSG.registerClickableObject({",
                "        object: \"ExitInspect\",",
                "        button: \"Left\",",
                "        duration: \"released\",",
                "        clickFunction: (obj) => {",
                "            GameVars.isInspecting = false;",
                "        }",
                "    });",
                "",
                "    FDSG.registerClickableObject({",
                "        object: \"PauseButton\",",
                "        button: \"Left\",",
                "        duration: \"released\",",
                "        clickFunction: (obj) => {",
                "            gdjs.evtTools.runtimeScene.pushScene(GameVars.runtimeScene, \"Pause Screen\"); // Pauses the current scene and loads the \"Pause Screen\" Scene",
                "        }",
                "    });",
                "",
                "    FDSG.registerClickableObject({",
                "        object: \"StatueCollectible\",",
                "        button: \"Left\",",
                "        duration: \"released\",",
                "        clickFunction: (obj) => {",
                "            if (FDSG.collectObject(obj)) { // Try and collect the statue",
                "                GameVars.statuesCollected += 1;",
                "                FDSG.updateStatueCounter();",
                "            }",
                "        }",
                "    });",
                "",
                "    Game.getVariables().get(\"DataInitialized\").setBoolean(true); // Sets the DataInitialized variable to true so that definitions are only made once",
                "    console.log(\"initialized custom game data\");",
                "}",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": []
        }
      ],
      "parameters": []
    },
    {
      "colorB": 228,
      "colorG": 176,
      "colorR": 74,
      "creationTime": 0,
      "name": "Main Game Loop",
      "source": "",
      "type": "BuiltinCommonInstructions::Group",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const FDSG = gdjs.FDGameData; // Simpler variables to use as reference",
            "const GameVars = FDSG.GameVars;",
            "",
            "if (gdjs.evtTools.runtimeScene.sceneJustBegins(runtimeScene)) { // Runs only at the beginning of the scene",
            "    GameVars.runtimeScene = runtimeScene; // Update the current RuntimeScene object",
            "    FDSG.initScene(runtimeScene);",
            "    console.log(\"Initialized scene\");",
            "    GameVars.isInspecting = false;",
            "}",
            "",
            "FDSG.handleClickableObjects(); // Handle all registered functions associated with clicking objects"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": []
    }
  ]
}